  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]

  	// 画素情報と周辺平均を投げると条件によってノイズの画素を綺麗にする
	void remove_noise_pixel(vector<vector<int>>& nonoise_data,
    int h,int w,int peripheral_ave){
		if(data[h][w] == 0 && 
        peripheral_ave > REMOVE_NOISE_WHITE_THRESHOLD){
			nonoise_data[h][w] = 255;
		}
		else if(data[h][w] == 255 && peripheral_ave < REMOVE_NOISE_BLACK_THRESHOLD){
			nonoise_data[h][w] = 0;
		}else{
			nonoise_data[h][w] = data[h][w];
		}
	
	}

}

  // ノイズ除去
  void remove_noise(){
    int peripheral_ave = 0;

    vector<vector<int>> nonoise_data;
    nonoise_data.resize(H);
    for(int i=0; i<H; i++){
      nonoise_data[i].resize(W);
    }
    
    for(int h=0; h<H; h++){
      for(int w=0; w<W; w++){
        // 四辺上の端は周辺1画素ずつは取れない(はみ出す)ので対策
        if(h == 0){
          // 上辺
          if(w==0){
            peripheral_ave = (data[h][w+1] + data[h+1][w] + data[h+1][w+1]) / 3;
          }
          if(w==W){
            peripheral_ave = (data[h][w-1] + data[h+1][w-1] + data[h+1][w]) / 3;
          }else{
            peripheral_ave = (data[h][w-1] + data[h][w+1] + data[h+1][w-1] 
            + data[h+1][w] + data[h+1][w+1]) / 5;
          }
          remove_noise_pixel(nonoise_data,h,w,peripheral_ave);
        }else if(h == H-1){
          // 下辺
          if(w==0){
            peripheral_ave = (data[h-1][w] + data[h-1][w+1] + data[h][w+1]) / 3;
          }
          if(w==W){
            peripheral_ave = (data[h-1][w-1] + data[h-1][w] + data[h][w-1]) / 3;
          }else{
            peripheral_ave = (data[h-1][w-1] + data[h-1][w] + data[h-1][w+1] 
            + data[h][w-1] + data[h][w+1]) / 5;
          }
          remove_noise_pixel(nonoise_data,h,w,peripheral_ave);
        }else if(w == 0){
          // 左辺
          peripheral_ave = (data[h-1][w] + data[h-1][w+1] + data[h][w+1] 
          + data[h+1][w] + data[h+1][w+1]) / 5;
          remove_noise_pixel(nonoise_data,h,w,peripheral_ave);
        }else if(w == W-1){
          // 右辺
          peripheral_ave = (data[h-1][w-1] + data[h-1][w] + data[h][w-1]
           + data[h+1][w-1] + data[h+1][w]) / 5;
          remove_noise_pixel(nonoise_data,h,w,peripheral_ave);
        }
        // 隣接周辺画素がすべて取れるエリア
        else if(data[h][w] == 0){
          // 黒画素
          peripheral_ave = (data[h-1][w-1] + data[h-1][w] + data[h-1][w+1] 
          + data[h][w-1] + data[h][w+1] + data[h+1][w-1] + data[h+1][w] 
          + data[h+1][w+1]) / 8;
          if(count_black(h,w) < 4){
            nonoise_data[h][w] = 255;
          }else if(peripheral_ave > REMOVE_NOISE_WHITE_THRESHOLD){
            nonoise_data[h][w] = 255;
          }else{
            nonoise_data[h][w] = data[h][w];
          }
        }else if(data[h][w] == 255){
          // 白画素
          peripheral_ave = (data[h-1][w-1] + data[h-1][w] + data[h-1][w+1]
           + data[h][w-1] + data[h][w+1] + data[h+1][w-1] + data[h+1][w] 
           + data[h+1][w+1]) / 8;
          if(count_white(h,w) < 4){
            nonoise_data[h][w] = 0;
          }else if(peripheral_ave < REMOVE_NOISE_BLACK_THRESHOLD){
            nonoise_data[h][w] = 0;
          }else{
            nonoise_data[h][w] = data[h][w];
          }
        }else{
          nonoise_data[h][w] = data[h][w];
        }
      }
    }
    data = nonoise_data;
  }

  \end{lstlisting}
