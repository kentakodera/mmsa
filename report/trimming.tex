  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]

  // 未踏はfalse, 訪問済みtrue
  // 0が入っている場所はtrue, ついでに総面積S(=画素値の合計)も算出
  void makevisited(){
    visited.resize(H);
    for(int i=0; i<H; i++){
      visited[i].assign(W,false);
    }
    S = 0;
    for(int h=0; h<H; h++){
      for(int w=0; w<W; w++){
        if(data[h][w] == 0){
          visited[h][w] = true;
        }
        else{
          S += data[h][w];
        }
      }
    }
  }


  // 内接する四角の左上端と幅，オブジェクトの画素値の合計を計算
  void trimming(int h, int w){
    queue<Point> que;
    int dp[3] = {-1,0,1};
    que.push({h,w});
    visited[h][w] = true; 
    S_trim = data[h][w];
    int max_h=0, min_h=MAX, max_w=0, min_w=MAX;
    while(que.size()){
      Point p = que.front(); que.pop();
      max_h = max(max_h, p.h);
      min_h = min(min_h, p.h);
      max_w = max(max_w, p.w);
      min_w = min(min_w, p.w);
      for(int i=0; i<3; i++){
        for(int j=0; j<3; j++){
          Point np = {p.h + dp[i], p.w + dp[j]};
          if(np.h>=0 && np.h<H && np.w>=0 && np.w<W){
            if(! visited[np.h][np.w]){
              que.push(np);
              S_trim += data[np.h][np.w];
              visited[np.h][np.w] = true;
            }
          }
        }
      }
    }
    upleft.h = min_h;
    upleft.w = min_w;
    H_trim = max_h - min_h;
    W_trim = max_w - min_w;
  }

     \end{lstlisting}